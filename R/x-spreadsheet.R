#' @title x-spreadsheet htmlwidget
#'
#' @description Initialises the x-spreadsheet htmlwidget, allows to
#' create one or more sheets and pass options.
#'
#' @param data The data to render inside the spreadsheet, the following
#' options are valid:
#' - NULL, this will result in an empty spreadsheet with a single sheet
#' named "Sheet1"
#' - A single data.frame object, this will result in a single sheet
#' spreadsheet where the name of the first sheet is "Sheet1"
#' - A named list where each list entry contains a data.frame object,
#' a named sheet is generated in correspondence with the named list
#' - A named list following the x-spreadsheet JSON structure, allowing
#' to set styles and other metadata - TBD
#' @param options A list containing table options/settings, set at
#' table initialisation.
#' The list should match the JSON structure below, e.g.: list(
#' "mode" = "edit", showToolbar = TRUE, ...)
#' {
#'   mode: 'edit', // edit | read
#'   showToolbar: true,
#'   showGrid: true,
#'   showContextmenu: true,
#'   view: {
#'     height: () => document.documentElement.clientHeight,
#'     width: () => document.documentElement.clientWidth,
#'   },
#'   row: {
#'     len: 100,
#'     height: 25,
#'   },
#'   col: {
#'     len: 26,
#'     width: 100,
#'     indexWidth: 60,
#'     minWidth: 60,
#'   },
#'   style: {
#'     bgcolor: '#ffffff',
#'     align: 'left',
#'     valign: 'middle',
#'     textwrap: false,
#'     strike: false,
#'     underline: false,
#'     color: '#0a0a0a',
#'     font: {
#'       name: 'Helvetica',
#'       size: 10,
#'       bold: false,
#'       italic: false,
#'     },
#'   },
#' }
#' @param elementId htmlwidget elementid
#' @export
xSpreadsheet <- function(data, options = NULL, elementId = NULL) {
  data <- processInputData(data)

  message <- list(
    data = data,
    options = options
  )

  # create widget
  htmlwidgets::createWidget(
    name = "xspreadsheet",
    message,
    package = "RXSpreadsheet",
    elementId = elementId
  )
}

#' @title Process data for RXSpreadsheet
#'
#' @description Process data for RXSpreadsheet,
#' this function turns the different structures allowed for data into the same
#' format that is expected by the client side logic.
#' @inheritParams rXSpreadsheet
processInputData <- function(data) {
  # check if data is a data.frame,
  # or a named list with one or more data.frame entries
  if (is.null(data)) {
    return(list("Sheet1" = data.frame()))
  } else if (is.data.frame(data)) {
    # single data.frame
    data <- list("Sheet1" = data)
  } else if (is.list(data)) {
    # check if list contains data.frame entries
    if (all(sapply(data, is.data.frame))) {
      # named list with data.frame entries
      data <- data
    } else {
      # named list with other entries
      stop("Data must be a data.frame or a named list with data.frame entries")
    }
  } else {
    # other data types
    stop("Data must be a data.frame or a named list with data.frame entries")
  }

  # convert data to x-spreadsheet format
  data <- listToxSpreadsheet(data)

  return(data)
}

listToxSpreadsheet <- function(list) {
  sheets <- lapply(names(list), function(name) {
    df <- list[[name]]
    list(name = name, rows = dfToxSpreadsheet(df))
  })
  return(sheets)
}

#' @title Convert a data.frame to x-spreadsheet format
#' @description Convert a data.frame to x-spreadsheet format,
#' while also adding data types in JSON format for later
#' conversion back to R.
dfToxSpreadsheet <- function(df, headerRow = TRUE) {
  # store in a list
  if (headerRow) {
    headerDf <- as.data.frame(t(names(df)))
    dfList <- list(headerDf, df)
  } else {
    dfList <- list(df)
  }

  rowsList <- lapply(dfList, function(l) {
    rowSeq <- seq_len(nrow(l))
    colSeq <- seq_len(ncol(l))

    rows <- lapply(rowSeq, function(i) {
      cells <- lapply(colSeq, function(j) {
        list(text = l[i, j],
             # add data type for accurate conversion back to R
             # possible improvement: shorten type labels to save space
             type = typeof(l[i, j]),
             header = if (i == 1) {
               TRUE
             } else {
               FALSE
             }
        )
      })
      # the - 1 is important to be consistent with
      # the JS indexing
      # -> removing this will result in data being inserted
      # 1 column to the right
      list(cells = setNames(cells, seq_along(cells) - 1))
    })
    rows
  })

  # unlist top level
  rows <- unlist(rowsList, recursive = FALSE)

  setNames(rows, seq_along(rows))

  rows
}

#' @title Convert x-spreadsheet data to a list of data.frames
#' @description Convert x-spreadsheet data to a list of data.frames,
#' this function turns the data structure generated by the JS library
#' (and parsed with jsonlite::fromJSON(simpifyVector = FALSE)))
#' into a list of data.frames, one per sheet. It is the inverse of
#' listToxSpreadsheet.
#' @param data The data to convert, a list with the following structure
#' - name
#' - rows, which contains "cells", which contains entries with "text"
#' other fields are ignored for now
#' (customise this function and jsso it carries the following metadata:
#' - field type for conversion
#' - column names Y/N
#' )
#' originating from a JSON object returned by x-spreadsheet,
#' containing one entry per sheet, with the following structure:
#' {
#'  name: "Sheet1",
#'  rows: {
#'  0: {
#'    cells: {
#'      {text: "A1"},
#'    }
#'  }
#' }
#' @param headerRow Whether the first row contains column names,
#' TO DO: automatically detect this by carrying extra metadata with
#' each sheet
#' @export
xSpreadsheetListToDf <- function(data, headerRow = TRUE) {

  dfs <- setNames(lapply(data, function(sheet) {
    sheetRows <- sheet$rows
    sheetName <- sheet$name

    cols <- NULL
    if ("header" %in% names(sheetRows[[1]]$cells[[1]])) {
        cols <- sapply(sheetRows[[1]]$cells, function(x) {
          cellTypeConversion(x)
        })
    }

    lapplyIter <- seq_along(sheetRows)
    if (!is.null(cols)) {
      lapplyIter <- lapplyIter[-1]
    }
    sheetDf <- lapply(lapplyIter, function(i) {
      if (!"cells" %in% names(sheetRows[[i]])) {
        return(NULL)
      } else {
        sapply(sheetRows[[i]]$cells, function(x) {
          cellTypeConversion(x)
        })
      }
    })

    # Convert to data.frame
    df <- do.call(rbind.data.frame, sheetDf)
    names(df) <- cols

    # return df directly
    df

  }), sapply(data, function(sheet) sheet$name)) # set names

  # return the list of data.frames
  dfs
}

# helper function, x$type is set via base::typeof
#' @param x A list with the following structure:
#' - text: the text to convert
#' - type: the type to convert to
#' originating from a JSON object returned by x-spreadsheet
cellTypeConversion <- function(x) {
      if ("type" %in% names(x)) {
        # convert x to the correct type
        switch(x$type,
               "character" = x$text,
               "double" = as.numeric(x$text),
               "integer" = as.integer(x$text),
               "logical" = as.logical(x$text),
               "complex" = as.complex(x$text),
               "raw" = as.raw(x$text),
               x$test)
      } else {
        return(x$text)
      }
}

#' Shiny bindings for RXSpreadsheet
#'
#' Output and render functions for using RXSpreadsheet within Shiny
#' applications and interactive Rmd documents.
#'
#' @param outputId output variable to read from
#' @param width,height Must be a valid CSS unit (like \code{'100\%'},
#'   \code{'400px'}, \code{'auto'}) or a number, which will be coerced to a
#'   string and have \code{'px'} appended.
#' @param expr An expression that generates a RXSpreadsheet
#' @param env The environment in which to evaluate \code{expr}.
#' @param quoted Is \code{expr} a quoted expression (with \code{quote()})? This
#'   is useful if you want to save an expression in a variable.
#'
#' @name RXSpreadsheet-shiny
#'
#' @export
RXSpreadsheetOutput <- function(outputId, width = "100%", height = "400px") {
  try({
    shiny::removeInputHandler("rxspreadsheetlist")
  })
  shiny::registerInputHandler("rxspreadsheetlist", function(data, ...) {
    list(data)
  }, force = TRUE)

  htmlwidgets::shinyWidgetOutput(outputId, "xspreadsheet",
    width, height,
    package = "RXSpreadsheet"
  )
}

#' @rdname RXSpreadsheet-shiny
#' @export
renderRXSpreadsheet <- function(expr, env = parent.frame(), quoted = FALSE) {
  if (!quoted) {
    expr <- substitute(expr)
  } # force quoted
  htmlwidgets::shinyRenderWidget(expr, RXSpreadsheetOutput,
    env,
    quoted = TRUE
  )
}
